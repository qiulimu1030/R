# [9] "总市值..交易日期.2019.05.06..单位.亿元"
# [10] "市盈率.PE.TTM...交易日期.2019.05.06"
# [11] "现金净流量同比增长率..报告期.2016年年报..单位.."
# [12] "现金净流量同比增长率..报告期.2017年年报..单位.."
# [13] "现金净流量同比增长率..报告期.2018年年报..单位.."
stock.raw[10, 8]
stock <- 0
# 1. 确保稳定的现金流(最近4年): 经营活动产生的现金流量净额 > 归属母公司的净利润.
# 2. 确保现金流增长(最近3年): 经营活动产生的现金流量净额增速 > 0.
# 3. 营收增长(2019年1季度): 营收增幅 > 20%.
for (i in 1:nrow(stock.raw)) {
if (stock.raw[i, 7] > 0 & stock.raw[i, 6] > 0 & stock.raw[i, 5] > 0 & stock.raw[i, 4] > 0
& stock.raw[i, 13] > 0 & stock.raw[i, 12] > 0 & stock.raw[i, 11] > 0
& stock.raw[i, 8] > 20)
{stock <- c(stock, i)}
}
stock <- stock[-1]
stock
length(stock) # 股票数量
for (i in 1:length(stock)) {
}
cat(stock.raw[i, 1], stock.raw[i, 2])
for (i in 1:length(stock)) {
cat(stock.raw[i, 1], stock.raw[i, 2])
}
for (i in 1:length(stock)) {
cat(stock.raw[i, 1], stock.raw[i, 2])
}
for (i in 1:length(stock)) {
cat(stock.raw[stock[i], 1], stock.raw[stock[i], 2])
}
stock[1]
stock
stock.raw[924, 1]
stock.raw[924, 2]
stock.raw[stock[1], 2]
for (i in 1:length(stock)) {
print(stock.raw[stock[i], 2])
}
stock.raw[stock[1], 2]
stock.raw[stock[1], 2][1]
stock <- 0
# 1. 确保稳定的现金流(最近4年): 经营活动产生的现金流量净额 > 归属母公司的净利润.
# 2. 确保现金流增长(最近3年): 经营活动产生的现金流量净额增速 > 0.
# 3. 营收增长(2019年1季度): 营收增幅 > 20%.
for (i in 1:nrow(stock.raw)) {
if (stock.raw[i, 7] > 0 & stock.raw[i, 6] > 0 & stock.raw[i, 5] > 0 & stock.raw[i, 4] > 0
& stock.raw[i, 13] > 0 & stock.raw[i, 12] > 0 & stock.raw[i, 11] > 0
& stock.raw[i, 8] > 20)
{stock <- c(stock, i)}
}
stock <- stock[-1]
stock # 股票序列
length(stock) # 股票数量
for (i in 1:length(stock)) {
print(stock.raw[stock[i], 2])
}
stock <- 0
# 1. 确保稳定的现金流(最近4年): 经营活动产生的现金流量净额 > 归属母公司的净利润.
# 2. 确保现金流增长(最近3年): 经营活动产生的现金流量净额增速 > 0.
# 3. 营收增长(2019年1季度): 营收增幅 > 20%.
# 4. 大盘股: 市值 >= 100亿元.
for (i in 1:nrow(stock.raw)) {
if (stock.raw[i, 7] > 0 & stock.raw[i, 6] > 0 & stock.raw[i, 5] > 0 & stock.raw[i, 4] > 0
& stock.raw[i, 13] > 0 & stock.raw[i, 12] > 0 & stock.raw[i, 11] > 0
& stock.raw[i, 8] > 20
& stock.raw[i, 9] >= 100)
{stock <- c(stock, i)}
}
stock <- stock[-1]
stock # 股票序列
length(stock) # 股票数量
for (i in 1:length(stock)) {
print(stock.raw[stock[i], 2])
}
acf(a.d1, lag.max = 20)
##########
# Part A #
##########
# 1. Load data
data("AirPassengers")
# The classic Box & Jenkins airline data. Monthly totals of international airline passengers, 1949 to 1960.
a <- AirPassengers
# 2. Decompose data
plot.ts(a)
# The plot shows the time series
a.d <- decompose(a)
plot(a.d)
# The plot shows the original time series (top), the estimated trend component (second from top),
# the estimated seasonal component (third from top), and the estimated irregular component (bottom).
# We see that the estimated trend component shows continuous increase from about 100 in 1949 to about 450 in 1960.
a.a <- a - a.d$seasonal
plot(a.a)
# The plot shows the original time series without seasonal time series.
a.a2 <- a - a.d$seasonal - a.d$random
plot(a.a2)
##########
# Part B #
##########
plot.ts(a)
a.d1 <- diff(a, differences = 1)
plot(a.d1)
acf(a.d1, lag.max = 20)
acf(a.d1, lag.max = 20, plot = F)
# The plot shows the original time series (top), the estimated trend component (second from top),
# the estimated seasonal component (third from top), and the estimated irregular component (bottom).
# We see that the estimated trend component shows continuous increase from about 100 in 1949 to about 450 in 1960.
a.a <- a - a.d$seasonal
plot(a.a)
library(tseries）
library(tseries)
pacf(a.d1, lag.max = 20)
pacf(a.d1, lag.max = 20, plot = F)
acf(a.d1, lag.max = 20)
# The plot shows the original time series (top), the estimated trend component (second from top),
# the estimated seasonal component (third from top), and the estimated irregular component (bottom).
# We see that the estimated trend component shows continuous increase from about 100 in 1949 to about 450 in 1960.
a.a <- a - a.d$seasonal
plot(a.a)
# The plot shows the original time series without seasonal time series.
a.a2 <- a - a.d$seasonal - a.d$random
plot(a.a2)
plot(a.d)
plot(a.d)
# 2. Decompose data
plot.ts(a)
plot(a - a.d$trend)
a
# 2. Decompose data
plot.ts(a)
>abline(reg=lm(a ~ time(a)))
abline(reg=lm(a ~ time(a)))
cycle(a)
plot(aggregate(a, FUN=mean))
boxplot(a ~ cycle(a))
plot(a.d)
# 2. Analyze data
plot.ts(a)
abline(reg=lm(a ~ time(a)))
plot(aggregate(a, FUN=mean))
cycle(a)
boxplot(a ~ cycle(a))
plot(a.d)
# The plot shows the original time series (top), the estimated trend component (second from top),
# the estimated seasonal component (third from top), and the estimated irregular component (bottom).
# We see that the estimated trend component shows continuous increase from about 100 in 1949 to about 450 in 1960.
a.a <- a - a.d$seasonal
plot(a.a)
acf(a.d1, lag.max = 20)
acf(a.d1, lag.max = 20, plot = F)
acf(a.d1, lag.max = 20)
acf(a.d1, lag.max = 20, plot = F)
pacf(a.d1, lag.max = 20)
plot(a.a)
plot(a - a.d$trend)
for (i in 1:length(stock)) {
print(stock.raw[stock[i], 2])
}
a
# 2. Analyze data
plot.ts(a)
a
# 2. Analyze data
plot.ts(a)
abline(reg=lm(a ~ time(a)))
plot(aggregate(a, FUN=mean))
cycle(a)
boxplot(a ~ cycle(a))
plot(a.d)
# The plot shows the original time series (top), the estimated trend component (second from top),
# the estimated seasonal component (third from top), and the estimated irregular component (bottom).
# We see that the estimated trend component shows continuous increase from about 100 in 1949 to about 450 in 1960.
a.a <- a - a.d$seasonal
plot(a.a)
acf(a)
acf(a.d1, lag.max = 20)
pacf(a.d1, lag.max = 20)
pacf(a.d1, lag.max = 20, plot = F)
acf(a)
acf(log(a))
pacf(a)
a.b <- a - a.d$trend
a.b
plot(a.b)
acf(a.b)
acf(a)
acf(a.b)
adf.test(diff(log(AirPassengers)), alternative="stationary", k=0)
acf(a.d1, lag.max = 20)
acf(a.d1, lag.max = 20, plot = F)
pacf(a.d1, lag.max = 20)
pacf(a.d1, lag.max = 20, plot = F)
install.packages("tseries")
install.packages("tseries")
# ALY6015-Module 5 Project – Danlin Shen – 1st Version
install.packages("TTR")
library(TTR)
library(tseries)
install.packages("forecast")
library(forecast)
adf.test(diff(log(a)), alternative="stationary", k=0)
adf.test(log(a), alternative="stationary", k=0)
a.d1 <- diff(log(a), differences = 1)
plot(a.d1)
plot(diff(a), differences = 1)
##########
# Part B #
##########
plot.ts(a)
acf(a)
acf(log(a))
pacf(log(1))
pacf(log(a))
plot(a.d1)
acf(a.d1, lag.max = 20)
acf(a.d1, lag.max = 20, plot = F)
pacf(a.d1, lag.max = 20)
pacf(a.d1, lag.max = 20, plot = F)
acf(a.d1, lag.max = 20)
fit <- arima(log(a), c(0, 1, 1),seasonal = list(order = c(0, 1, 1), period = 12))
pred <- predict(fit, n.ahead = 10*12)
ts.plot(a,2.718^pred$pred, log = "y", lty = c(1,3))
fit1 <- arima(log(a), c(0, 1, 1),seasonal = list(order = c(0, 1, 1), period = 12))
pred1 <- predict(fit1, n.ahead = 10*12)
ts.plot(a,2.718^pred1$pred, log = "y", lty = c(1,3))
fit2 <- arima(log(a), c(0, 1, 2),seasonal = list(order = c(0, 1, 1), period = 12))
pred2 <- predict(fit2, n.ahead = 10*12)
ts.plot(a,2.718^pred2$pred, log = "y", lty = c(1,3))
acf(a.d1, lag.max = 20) # p = 0, q = 1 or 2
acf(a.d1, lag.max = 20) # p = 0, d = 1, q = 1 or 2
pacf(a.d1, lag.max = 20)
pacf(a)
pacf(log(a))
pacf(log(a))
pacf(diff(log(a)))
pacf(a.d1, lag.max = 20)
pacf(diff(log(a)))
acf(a.d1, lag.max = 20) #  q = 1 or 2
##########
# Part B #
##########
plot.ts(a)
adf.test(diff(log(a)), alternative="stationary", k=0) # Stationary series
adf.test(diff(log(a)), alternative="stationary", k=0) # Stationary series
acf(log(a))
pacf(log(a))
acf(log(a))
pacf(log(a))
plot(a.d1)
acf(a.d1, lag.max = 20) #  q = 1 or 2
# an ARMA(0,1) model, that is, a moving average model of order q=1, since the autocorrelogram is zero after
# lag 1 and the partial autocorrelogram tails off to zero.
acf(a.d1, lag.max = 20, plot = F)
# an ARMA(0,1) model, that is, a moving average model of order q=1, since the autocorrelogram is zero after
# lag 1 and the partial autocorrelogram tails off to zero.
acf(a.d1, lag.max = 20, plot = F)
pacf(a.d1, lag.max = 20)
# p = 0, an ARMA(0,0) model, that is, an autoregressive model of order p=0, since the partial autocorrelogram
# is zero after lag 0, and the autocorrelogram tails off to zero (although perhaps too abruptly for this model
# to be appropriate)
pacf(a.d1, lag.max = 20, plot = F)
# p = 0, an ARMA(0,0) model, that is, an autoregressive model of order p=0, since the partial autocorrelogram
# is zero after lag 0, and the autocorrelogram tails off to zero (although perhaps too abruptly for this model
# to be appropriate)
pacf(a.d1, lag.max = 20, plot = F)
fit <- arima(log(a), c(0, 1, 1),seasonal = list(order = c(0, 1, 1), period = 12))
fit <- arima(log(a), c(0, 1, 1),seasonal = list(order = c(0, 1, 1), period = 12))
pred <- predict(fit, n.ahead = 10*12)
ts.plot(a,2.718^pred$pred, log = "y", lty = c(1,3))
plot(a)
install.packages("factoextra")
install.packages("NbClust")
install.packages("party")
install.packages("randomForest")
install.packages("dbscan")
install.packages("fpc")
library(party)
library(MASS)
# Part A
str(Boston)
Boston
# nB: new Boston data.
nB <- Boston
nB
class(nB)
nB.matraix <- as.matrix(Boston)
nB.matraix
nB.norm <- apply(nB, 2, function(x) scale(x, center = T, scale = T)/norm(scale(x, center = T, scale = T), "1"))
nB.norm
# Part B
set.seed(200)
nB2 <- nB
# k-means clustering
nB.kmeans <- kmeans(nB2, 5)
# check result
table(nB$Price, nB.kmeans$cluster)
summary(nB)
# plot clusters and their centers
plot(nB2[c("crim", "tax")], col=nB.kmeans$cluster)
# plot clusters and their centers
plot(nB.norm[c("crim", "tax")], col=nB.kmeans$cluster)
nB2 <- nB.norm
# k-means clustering
nB.norm.kmeans <- kmeans(nB2, 5)
# check result
table(nB.norm$Price, nB.kmeans$cluster)
nB.norm
nB.norm.kmeans
# plot clusters and their centers
plot(nB2[c("crim", "tax")], col=nB.norm.kmeans$cluster)
# price: Price per suqared meter(unit: ¥, Yuan)
# subway: Is there a subway nearby?
# district: Distance from the city center (unit: km).
# square: Housing area (unit: square meters).
# livingRoom: Number of living rooms.
# drawingRoom: Number of drawing rooms.
# kitchen: Number of kitchens.
# bathRoom: Number of bathrooms.
Housing.original <- read.table("Desktop/Beijing Price.csv", head=TRUE, sep=",") # The working diriction maybe changed
Housing.original # Housing.original is the data that should not be modified.
####################################
# Data Preprocessing - Danlin Shen #
####################################
# 1. Convert all of the data: All of the matrix will be standardized to have unit L1 norm in each column and
# zero mean. L1 norm is uesd for Lasso and descision tree.
Housing.norm <- apply(Housing.original, 2, function(x) scale(x, center = T, scale = T)/norm(scale(x, center = T, scale = T), "1"))
Housing.norm # Housing.norm is the data have been standardized to have unit L1 norm in each column and zero mean.
# Exlanation & Testing
# Before we start analyzing the data, we have to preprocess the data -- if you don't, the data won't be in the
# same range. For example, in this program, we can't directly compare the relationships in the numbers of the
# bathroom, the price per squared meter, and the distance from the city center, because they have huge differences
# in position and scale that in the coordinate system. Therefore, through data preprocessing, we can put all of
# the variables near the origin of the coordinate system without changing the data distribution. I will use
# z-mean and L1 normalization. Step 1 is to move the data to the origin. Step 2 is to compress the range
# of the data to [0, 1].
sub.o <- Housing.original$subway
sub.1<- sub.o - mean(sub.o) # Step 1
sub.2 <- (sub.o - mean(sub.o))/(sd(sub.o)) # Step 2
sub.2/norm(as.matrix(sub.2), "1")  # Step 2
# 2. Add the discription of the price
price <- Housing.original$price
summary(price) # Find out the minmum, the 1st quantile, the median, the mean, the 3
boxplot(price)
# Description: Classify Beijing's house prices according to the price quartiles.
# Testing
for (i in 1:100) {
if (price[i] < 27806) {cat(i, ":", price[i], "Poor","\n")}
if (27806 <= price[i] & price[i]  < 38292) {cat(i, ":", price[i], "Cheap","\n")}
if (38292 <= price[i] & price[i]  < 54240) {cat(i, ":", price[i], "Medium","\n")}
if (54240 <= price[i] & price[i]  < 90000) {cat(i, ":", price[i], "Expensive","\n")}
if (90000 <= price[i]) {cat(i, ":", price[i], "Luxary","\n")}
}
# The decision tree can only predict data using numerical data or categorical data. Essentially,
# this is a data classification. Therefore categorical data must be used as the y value. Since the original
# data does not have a y value, I use a piece of code to generate the y value.
Housing.tree <- Housing.original
for (i in 1:nrow(Housing.tree)) {
if (Housing.tree$price[i] < 27806) {Housing.tree$Description[i] <- "Poor"}
if (27806 <= Housing.tree$price[i] & price[i]  < 38292) {Housing.tree$Description[i] <- "Cheap"}
if (38292 <= Housing.tree$price[i] & price[i]  < 54240) {Housing.tree$Description[i] <- "Medium"}
if (54240 <= Housing.tree$price[i] & price[i]  < 90000) {Housing.tree$Description[i] <- "Expensive"}
if (90000 <= Housing.tree$price[i]) {Housing.tree$Description[i] <- "Luxury"}
}
Housing.tree # Housing.tree is the data that has extral label to dscribe the price
###############################
# Decision Tree - Danlin Shen #
###############################
# Generate Tree dataset
Housing.norm <- as.data.frame(Housing.norm)
Tree <- Housing.norm
Tree$Description <- factor(Housing.tree$Description) # Convert the Description from character to factor.
# split into training and test Housing.originals
set.seed(100) # set.seed(): Generate random numbers in a specific order for simple verification.
Tree.index <- sample(2, nrow(Tree), replace=TRUE, prob=c(0.7, 0.3))
Tree.train <- Tree[Tree.index==1, ]
Tree.test <- Tree[Tree.index==2, ]
str(Tree.train)
str(Tree.test)
# build a decision tree
Tree.formula <- Description ~ subway + district + square + livingRoom + drawingRoom + kitchen + bathRoom
Tree.ctree <- ctree(Tree.formula, data=Tree.train)
plot(Tree.ctree)
# predict on test data
pred <- predict(Tree.ctree, newdata = Tree.test) # check prediction result
table(pred, Tree.test$Description)
Tree.test
install.packages("ggcorrplot")
install.packages("shiny")
install.packages(c("cluster", "dendextend", "digest", "dplyr", "fpc", "ggcorrplot", "glmnet", "nlme", "pillar", "progress", "robustbase", "zip"))
install.packages("rPython")
# price: Price per suqared meter(unit: ¥, Yuan)
# subway: Is there a subway nearby?
# district: Distance from the city center (unit: km).
# square: Housing area (unit: square meters).
# livingRoom: Number of living rooms.
# drawingRoom: Number of drawing rooms.
# kitchen: Number of kitchens.
# bathRoom: Number of bathrooms.
Housing.original <- read.table("Desktop/Beijing Price.csv", head=TRUE, sep=",") # The working diriction maybe changed
getwd()
m <- matrix(1:12, nrow=4, byrow=T)
m
y <- -1:2
y
m.new <- m+y
m.new
t(m.new)
get.wd()
getwd()
getwd()
library("string")
source('~/Desktop/test.r')
install.packages("string")
install.packages("rpy")
install.packages("rpy2")
install.packages("rpython")
install.packages("rPython")
.libPaths()
.Library
r
R
.R
# 选股器 ver 1.0
# 2019.05.16
stock.raw <- read.table("Desktop/资料/股票/现金流数据.csv", , head = T, sep=",")
names(stock.raw)
library(tm)
install.packages(NLP)
install.packages("NLP")
library(tm)
install.packages("tm")
R version
version # R version
version # R version
print("Hello World")
install.packages("devtools") #assuming it is not already installed
library(devtools)
install_github("andreacirilloac/updateR")
version
pwd()
pwd()
getwd()
setwd("/Users/zack/Desktop/Code/R")
getwd()
file.create("FingersAndCars.txt")
setwd("/Users/zack/Desktop/Code/R/ALY 6040")
file.create("FingersAndCars.txt")
rep(123)
rep(123, 5)
c(rep(123, 5))
vv.factor <- c(rep(123, 5))
vv.factor
vv <- c(rep(123, 5))
vv
vv <- (rep(123, 5))
vv
class(vv)
vv <- c(rep(123, 5))
class(vv)
vv <- c(rep(123, 5))
vv
class(vv)
vv <- c(rep(123, 5))
vv
class(vv)
length(vv)
save(x, file = "vv.RData")
vv <- c(rep(123, 5))
vv
class(vv)
length(vv)
save(vv, file = "vv.RData")
load(vv.RData)
load("vv.RData")
tmp <- load("vv.RData")
tmp
vv
save(vv, file = "vv.RData")
tmp <- load("vv.RData")
tmp
tmp <- load("vv.vv.RData")
vv
vv <- c(rep(123, 5))
print(vv)
class(vv)
length(vv)
save(vv, file = "vv.RData")
rm(vv)
load("vv.RData")
print(vv)
# 4.
save(vv, file = "vv.RData", ascii = TRUE)
save(vv, file = "vv.RData")
# 4.
save(vv, file = "vv.txt", ascii = TRUE)
# 5.
list.files()
# 6.
ALY6040 <- list.files("/Users/zack/Desktop/Code/R/ALY 6070")
class(ALY6040)
str(vv)
mode(vv)
# 7.
rm(vv)
vv
load("vv.RData")
vv
# 8.
rm(vv)
vv
load("vv.txt")
vv
